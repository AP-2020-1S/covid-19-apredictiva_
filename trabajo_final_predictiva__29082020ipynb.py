# -*- coding: utf-8 -*-
"""Trabajo Final_Predictiva._29082020ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/JuanMaFB/JuanMaFB.github.io/blob/master/Trabajo_Final_Predictiva.ipynb

## Trabajo Final (Predictiva): Pronostico de la evolución de casos activos de SARS-CoV-2 en Colombia
El trabajo que se presenta a continuación tiene como objetivo la predicción de corto y mediano plazo de el total de casos confirmados, los nuevos casos, los casos activos, recuperados y muertes para las ciudades de Bogotá, Medellín, Cali, Barranquilla y Pereira, utilizando técnicas estadísticas, de inteligencia artificial o modelos híbridos.

El dataset que se utilizará es Casos positivos de COVID-19 en Colombia y se encuentra en www.datos.gov.co.

**Integrantes:**


*   José Andres Galeano - Grupo 2
*   Juan Manual Florez - Grupo 1 
*   Lina Victoria Parra Duque - Grupo 1
*   Yesica Andrea Velásquez - Grupo 3

## **Definición del problema real**
El covid a nivel mundial ha representado no solo un reto para los sistemas de salud sino también un reto económico y gubernamental, el nuevo Coronavirus (COVID-19) ha sido clasificado por la Organización Mundial de la Salud como una emergencia en  salud  pública  de  importancia  internacional  (ESPII).  Se  han  reconocido  casos  en  todos  los  continentes  y  el  6  de  marzo se confirmó el primer caso en Colombia (Díaz, 2020), realmente el primer brote en el mundo fue en  Diciembre del 2019 en China , pero este país logró identificar realmente la causal del virus  a principios de Enero 2020, cuando ya este había pasado a otros países.  
La pandemia por covid surgen de las particularidades del mismo virus pues a nivel epidemiológico, médico y social el conocimiento y medidas tomadas para combatir con este en base a incertidumbre total hace que las cifras y el tiempo de superación del virus varíen en todas las partes del mundo (Chaccour, 2020), el covid en las personas ocasionan infecciones respiratorias que consiguen ir desde el  resfriado  común  hasta  enfermedades  más  complicadas  como  el  síndrome  respiratorio  de  Oriente  Medio  (MERS) y   el   síndrome   respiratorio   agudo   severo   (SARS) (OMS, 2020) y se ha identificado además que es más probable que las personas mayores de edad o con sistemas inmunológicos ya afectados son más propensos a generar complicaciones si adquieren el virus. 
En Colombia las medidas para prevenir el contagio del covid desde el primer momento fueron extremas, es decir la población se sometió a una cuarentena obligatoria y a un cierre total de las actividades económicas, así mismo entendiendo que las personas del país la mayoría son trabajadores informales ( Wanderley, 2020) después de un mes de estas restricciones se empezó el proceso de reactivación que trajo consigo un aumento considerable de infectados llegando a un primer pico a finales de Julio, las bases de datos de infectados, muertes y recuperados reposan públicas y se actualizan constantemente y con estas se vienen realizando diferentes modelos para predecir no solo las condiciones futuras de la población para dar información sobre la salud del país, sino también por la preocupante situación económica y la reapertura de este sector. 
 
Basados en lo último el afán ahora es de retomar las actividades normales de las personas, para garantizar la manutención de las diferentes familias del país, entonces el propósito de lo siguiente es establecer una serie de predicciones de la condición del virus en diferentes ciudades representativas de Colombia  y determinar un fin de condiciones para la toma de decisiones de las medidas que se pueden tomar a partir de hoy para darle frente a la recuperación del país en relación al covid.


**Ref:**
Chaccour,   C.   COVID-19:   Cinco   respuestas   de   salud   pública   diferentes  ante  la  epidemia      [Internet].  2020  [citado  2020  marzo  26].   Disponible   en: https://www.isglobal.org/healthisglobal/-/custom-blog-portlet/covid-19-cinco-respuestas-de-salud-publica-diferentes-ante-la-epidemia/2877257/0
 
Organización Mundial de la Salud. OMS. Preguntas y respuestas sobre la enfermedad por coronavirus (COVID-19) [Internet]. 2020 [citado 2020 marzo 26]. Recuperado de: https://www.who.int/es/emergencies/diseases/novel-coronavirus-2019/advice-for-public/q-a-coronaviruses
 

Wanderley, F. Vera Cossio, H. Benavides JP. América Latina en la encrucijada del desarrollo sostenible e inclusivo -Bolivia, Ecuador, Colombia y Perú al inicio del siglo XXI. IISEC-UCB,2020.

## Descripción de las variables disponibles
Antes de realizar cualquier cálculo con un nuevo conjunto de datos, es importante realizar una exploración descriptiva de los mismos. Esto permitirá comprender la información que contiene cada variable y dar indicios sobre qué variables serían adecuadas usar o no en etapas posteriores de análisis.

Con base a la información facilitada en www.datos.gov.co., las variables en este conjunto de datos disponibles tenemos:


1.  ***id_de_caso:*** Corresponde a la identificación del caso.
2.   **fecha_de_notificaci_n**:Fecha de notificación a SIVIGILA.
3.  **c_digo_divipola:** Corresponde a una nomenclatura para la identificación de departamentos y municipios.
4.  **ciudad_de_ubicaci_n:** Se refiere a la ciudad en donde se presenta el evento.
5.  **departamento:** Se refiere al departamento en donde se presenta el evento.
6.  **atenci_n:** Se refiere al tipo de atención.
7.  **edad:** Corresponde a la edad del paciente.
8.  **sexo:** Corresponde al sexo del paciente.
9.  **tipo:** Corresponde al tipo de atención,  Importado: proveniente de otro pais, Relacionado: correponde a casos nacionales.
10.  **estado**: Corresponde a muertes no relacionadas con COVID-19, aún si eran casos activos **Hay pacientes recuperados para COVID-19, que pueden permanecer en hospitalización por otras comorbilidades.
11.  **pa_s_de_procedencia**: Se refiere al pais en donde se presenta el evento.
12.  **fis**: Fecha de inicio de síntoma.
13.  **fecha_de_muerte**: Corresponde a la fecha en que el paciente fallece.
14.  **fecha_diagnostico**: Fecha de confirmación por laboratorio.
15.  **fecha_recuperado**: Corresponde a la fecha en que el paciente ya no presenta sintomas y es confirmado mediante una prueba.
16.  **fecha_reporte_web**: Fecha de publicación en sitio web.
17.  **tipo_recuperaci_n**:  
Se refiere a la variable de tipo de recuperación que tiene dos opciones: PCR y tiempo. PCR indica que la persona se encuentra recuperada por segunda muestra, en donde dio negativo para el virus; mientras que tiempo significa que son personas que cumplieron 30 días posteriores al inicio de síntomas o toma de muestras que no tienen síntomas, que no tengan más de 70 años ni que estén hospitalizados.
18.  **codigo_departamento**: Corresponde al sistema de codificación para el departamento en donde se presenta el evento.
19.  **codigo_pais**:Corresponde al sistema de codificación para el pais en donde se presenta el evento.
20.  **pertenencia_etnica**: Esta variable se actualizará cada semana.
21.  **nombre_grupo_etnico**: Corresponde a el grupo etnico al que corresponde el paciente.

### *Lectura de la base de datos*
Se importan las librerías a utilizar y llamamos la base de datos:
"""

!pip install pandas
!pip install sodapy

## librerías
import pandas as pd
from sodapy import Socrata
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import datetime

cliente = Socrata("www.datos.gov.co", None)
df = cliente.get("gt2j-8ykr", limit=1000000)
# Convertir los datos a un DataFrame
df_0 = pd.DataFrame.from_records(df)

#Se realiza una copia de la base de datos
df_1= df_0.copy()
#df1 = pd.read_csv("https://www.datos.gov.co/api/views/gt2j-8ykr/rows.csv?accessType=DOWNLOAD")

"""## *Exploración de la base de datos*

A continuación analizamos las características de la base de datos buscando describir cómo se relaciona cada atributo con la variable objetivo
"""

#Columnas de la base de datos
print('Nombre columnas:',df_1.columns)

"""Se seleccionan las variables que harán parte del modelo, en este caso se tendran en cuenta: id_de_caso, fecha_de_notificaci_n      ciudad_de_ubicaci_n, fecha_diagnostico, fecha_reporte_web, fecha_recuperado y fecha_de_muerte"""

df0=df_1[['id_de_caso', 'fecha_de_notificaci_n',
       'ciudad_de_ubicaci_n',  'fecha_diagnostico', 'fecha_reporte_web', 'fecha_recuperado', 'fecha_de_muerte']]

"""Verificamos si todas las columnas tienen igual registros y tambien se puede ver que las columnas de la base de datos seleccionada contiene atributos del siguiente tipo objects:"""

df0.info()

"""Podemos observar que todas las columnas son de tipo object por lo tanto se deben de modificar las columnas  *fecha_de_notificaci_n, fecha_diagnostico, fecha_recuperado, fecha_reporte_web y fecha_de_muerte* a un tipo de datos ***datetime***, la columna *id_de_caso* se deben de modificar a tipo de datos ***int64***"""

df0['fecha_de_notificaci_n']= pd.to_datetime(df0['fecha_de_notificaci_n'])
df0['fecha_diagnostico']= pd.to_datetime(df0['fecha_diagnostico'])
df0['fecha_recuperado']= pd.to_datetime(df0['fecha_recuperado'])
df0['fecha_reporte_web']= pd.to_datetime(df0['fecha_reporte_web'])
df0['fecha_de_muerte']= pd.to_datetime(df0['fecha_de_muerte'])
df0['id_de_caso']= df0['id_de_caso'].values.astype(float)
df0 = df0.astype({'ciudad_de_ubicaci_n':'category',
       'id_de_caso':'int64'})

#Validamos el cambio de tipo de datos
df0.dtypes

"""Para el analisis solo tomaremos las Ciudades= Medellín, Bogotá D.C., Cali, Barranquilla y  Pereira"""

def filtrar_ciudad(df,Ciudad):
  df0_0 =df[df['ciudad_de_ubicaci_n']==Ciudad]
  df0_1=df0_0.groupby(['fecha_reporte_web']).size().cumsum().to_frame(name = 'Casos_Diagnostico').reset_index()
  df0_1=df0_1.rename(columns={'fecha_reporte_web': 'Fecha'})
  df0_2=df0_0.groupby(['fecha_recuperado']).size().cumsum().to_frame(name = 'Casos_Recuperado').reset_index()
  df0_2=df0_2.rename(columns={'fecha_recuperado': 'Fecha'})
  df0_3=df0_0[df0_0.fecha_recuperado.isnull()].groupby(['fecha_de_muerte']).size().cumsum().to_frame(name = 'Casos_Muerte').reset_index()
  df0_3=df0_3.rename(columns={'fecha_de_muerte': 'Fecha'})
  df0_0=pd.merge(df0_1, df0_2, on='Fecha',how='left')
  df0_0=pd.merge(df0_0, df0_3, on='Fecha',how='left')
  df0_0.sort_values('Fecha')
  df0_0=df0_0.fillna(method='ffill')
  df0_0=df0_0.fillna(0)
  df0_0["Casos_Activos"]=df0_0["Casos_Diagnostico"]-df0_0["Casos_Recuperado"]-df0_0["Casos_Muerte"]
  df0_0["Mes"]=pd.DatetimeIndex(df0_0['Fecha']).month
  df0_0["Dia"]=pd.DatetimeIndex(df0_0['Fecha']).day
  df0_0["Ciudad"]=Ciudad
  return df0_0

ciudad = ['Medellín','Bogotá D.C.','Cali','Barranquilla','Pereira']
for ci in ciudad:
      if ci=="Medellín":
        df_fnal=filtrar_ciudad(df0,ci)
      else:
        df_concat=filtrar_ciudad(df0,ci)
        df_fnal=pd.concat([df_fnal, df_concat])

"""Se modifica el nombre de la ciudad de **Cali** por **Santiago de Cali** con el fin de visualizarla en el mapa presentado en el dashboard (data studio), ya que la ciudad de Cali se visualizaba en otra parte del mundo."""

df0["ciudad_de_ubicaci_n"]=df0.ciudad_de_ubicaci_n.replace("Cali", "Santiago de Cali")

df0[df0["ciudad_de_ubicaci_n"]=="Santiago de Cali"]

df0[df0['ciudad_de_ubicaci_n']=="Santiago de"]

"""## *Análisis Descriptivo*

A continuación exploraremos los datos con el propósito es encontrar anomalías, patrones, tendencias o relaciones que nos puedan servir para tomar la decisión de que modelo utilizar
"""

df_fnal.groupby('Ciudad').max()["Casos_Diagnostico"].plot(kind='bar', title = 'Total diagnosticos por Ciudad')

"""De las cinco ciudades, Bogotá representa aproximadamente el 63% de los casos."""

# Numero de casos de diagnostico agrupado por Ciudad:
plt.rcParams["figure.figsize"] = (10,3.5)
casos = df_fnal.groupby(['Mes', 'Ciudad']).max()["Casos_Diagnostico"].unstack()
# genera el gráfico:
casos.plot(kind="bar", title = ' Casos Diagnosticados por Ciudad ')
plt.tight_layout()

"""Hoy las ciudades presentan los siguientes porcentajes de casos diagnosticados:"""

df_fnal.groupby(['Ciudad']).Casos_Diagnostico.max().to_frame(name="Porcentaje caso diagnostico").apply(lambda x: round( x/x.sum()*100))

# Numero de casos de recuperados agrupado por Ciudad:
plt.rcParams["figure.figsize"] = (10,3.5)
casos = df_fnal.groupby(['Mes', 'Ciudad']).max()["Casos_Recuperado"].unstack()
# genera el gráfico:
casos.plot(kind="bar", title = ' Casos Recuperados por Ciudad ')
plt.tight_layout()

"""Hoy las ciudades presentan los siguientes porcentajes de recuperación:"""

df_fnal.groupby(['Ciudad']).Casos_Recuperado.max().to_frame(name="Porcentaje caso Recuperado").apply(lambda x: round( x/x.sum()*100))

# Numero de casos de recuperados agrupado por Ciudad:
plt.rcParams["figure.figsize"] = (10,3.5)
casos = df_fnal.groupby(['Mes', 'Ciudad']).max()["Casos_Muerte"].unstack()
# genera el gráfico:
casos.plot(kind="bar", title = ' Casos de Muerte por Ciudad ')
plt.tight_layout()

"""Hoy las ciudades presentan los siguientes casos de muerte:"""

df_fnal.groupby(['Ciudad']).Casos_Muerte.max().to_frame(name="Porcentaje casos Muerte").apply(lambda x: round( x/x.sum()*100))

df_fnal.groupby('Mes').max()["Casos_Diagnostico"].plot(kind='bar')

df_fnal.groupby(['Mes']).Casos_Diagnostico.max()
print('Al dia de hoy hay ' + str(df_fnal['Casos_Diagnostico'].max())+ ' casos diagnosticados en las cinco ciudades')

med =df_fnal[df_fnal['Ciudad']=='Medellín']
bar =df_fnal[df_fnal['Ciudad']=='Barranquilla']
bog =df_fnal[df_fnal['Ciudad']=='Bogotá D.C.']
cal =df_fnal[df_fnal['Ciudad']=='Cali']
per =df_fnal[df_fnal['Ciudad']=='Pereira']

plt.rcParams["figure.figsize"] = (10,3.5)
med.groupby('Mes').max()["Casos_Diagnostico"].plot(kind='line',label='Medellin', title = 'Diagnosticos mes a mes por ciudad ')
bar.groupby('Mes').max()["Casos_Diagnostico"].plot(kind='line',label='Barranquilla')
bog.groupby('Mes').max()["Casos_Diagnostico"].plot(kind='line',label='Bogota')
cal.groupby('Mes').max()["Casos_Diagnostico"].plot(kind='line',label='Cali')
per.groupby('Mes').max()["Casos_Diagnostico"].plot(kind='line',label='Pereira')
plt.legend()
plt.show()

"""En los casos de diagnosticos se puede observar el crecimiento exponencial en la ciudad de Bogotá entre el mes 6 y 8, con respecto a las demás ciudades, tambien se puede observar el aplanamiento de la curva entre el mes 8 y el mes 9"""

plt.rcParams["figure.figsize"] = (10,3.5)
med.groupby('Mes').max()["Casos_Recuperado"].plot(kind='line',label='Medellin', title = 'Casos recuperados mes a mes por ciudad ')
bar.groupby('Mes').max()["Casos_Recuperado"].plot(kind='line',label='Barranquilla')
bog.groupby('Mes').max()["Casos_Recuperado"].plot(kind='line',label='Bogota')
cal.groupby('Mes').max()["Casos_Recuperado"].plot(kind='line',label='Cali')
per.groupby('Mes').max()["Casos_Recuperado"].plot(kind='line',label='Pereira')
plt.legend()
plt.show()

"""En los casos de recuperación se puede observar el crecimiento en la ciudad de Bogotá entre el mes 6 y 8, con respecto a las demás ciudades, tambien se puede observar que la ciudad de Medellín aumenta en los casos recuperados del mes 8 al 9, con respecto a Barranquilla, Cali y Pereira"""

plt.rcParams["figure.figsize"] = (10,3.5)
med.groupby('Mes').max()["Casos_Muerte"].plot(kind='line',label='Medellin', title = 'Casos de muertes mes a mes por ciudad ')
bar.groupby('Mes').max()["Casos_Muerte"].plot(kind='line',label='Barranquilla')
bog.groupby('Mes').max()["Casos_Muerte"].plot(kind='line',label='Bogota')
cal.groupby('Mes').max()["Casos_Muerte"].plot(kind='line',label='Cali')
per.groupby('Mes').max()["Casos_Muerte"].plot(kind='line',label='Pereira')
plt.legend()
plt.show()

"""En los casos de Muertes se observa que después de Bogotá esta la ciudad de Barranquilla con más muertes, le sigue Cali, Medellín y Pereira

## *Aplicación del modelo SIR*

El modelo SIR es uno de los modelos epidemiológicos más simples capaces de capturar muchas de las características típicas de los brotes epidémicos. El nombre del modelo proviene de las iniciales S (población susceptible), I (población infectada) y R (población recuperada). El modelo relaciona las variaciones de las tres poblaciones (Susceptible, Infectada y Recuperada) a través de la tasa de infección y el período infeccioso promedio.

Creamos una función para organizar la base de datos y calcular las tasas de contagio, muerte y recuperación
"""

def Agrupacion(df,Ciudad,Pobla,Tipo):

  ## Aquí se agrupan los casos por fecha y por ciudad para determinar las varibles necesarias para el modelo SIR

  df_Ciudad=df[df['ciudad_de_ubicaci_n']==Ciudad]
  df1=df_Ciudad.groupby(['fecha_reporte_web']).size().cumsum().to_frame(name = 'Casos_Diagnostico'+Tipo).reset_index()
  df1=df1.rename(columns={'fecha_reporte_web': 'Fecha'})
  df2=df_Ciudad.groupby(['fecha_recuperado']).size().cumsum().to_frame(name = 'Casos_Recuperado'+Tipo).reset_index()
  df2=df2.rename(columns={'fecha_recuperado': 'Fecha'})

  ## Se excluyen los datos donde se tiene fecha de recuperado  y además, fecha de muerte

  df3=df_Ciudad[df_Ciudad.fecha_recuperado.isnull()].groupby(['fecha_de_muerte']).size().cumsum().to_frame(name = 'Casos_Muerte'+Tipo).reset_index()
  df3=df3.rename(columns={'fecha_de_muerte': 'Fecha'})

  ## Aquí se concatenan las tablas de casos diagnosticados, recuperados y muertes

  df_Ciudad=pd.merge(df1, df2, on='Fecha',how='left')
  df_Ciudad=pd.merge(df_Ciudad, df3, on='Fecha',how='left')

  ## Aquí se ordena por fecha

  df_Ciudad.sort_values('Fecha')

  ## Aquí se llenan los datos vacíos copiando el dato anterior

  df_Ciudad=df_Ciudad.fillna(method='ffill')

  ## Aquí se llenan los datos vacíos que no tienen datos anteriores

  df_Ciudad=df_Ciudad.fillna(0)

  ## Cáculo de casos activos

  df_Ciudad["Casos_Activos"+ Tipo]=df_Ciudad["Casos_Diagnostico"+ Tipo]-df_Ciudad["Casos_Recuperado"+ Tipo]-df_Ciudad["Casos_Muerte"+ Tipo]
 
  ## Cáculo de tasas de contagio, recuperación y muerte

  df_Ciudad["Tasa_Contagio"+ Tipo]=""
  for k in range(len(df_Ciudad['Fecha'])-1):
    df_Ciudad["Tasa_Contagio"+ Tipo][k+1]=(df_Ciudad['Casos_Diagnostico'+ Tipo][k+1]-df_Ciudad['Casos_Diagnostico'+ Tipo][k])*Pobla/(df_Ciudad['Casos_Activos'+ Tipo][k]*(Pobla-df_Ciudad['Casos_Diagnostico'+ Tipo][k]))

  df_Ciudad["Tasa_Recuperacion"+ Tipo]=""
  for k in range(len(df_Ciudad['Fecha'])-1):
    df_Ciudad["Tasa_Recuperacion"+ Tipo][k+1]=(df_Ciudad['Casos_Recuperado'+ Tipo][k+1]-df_Ciudad['Casos_Recuperado'+ Tipo][k])/(df_Ciudad['Casos_Activos'+ Tipo][k])

  df_Ciudad["Tasa_Muerte"+Tipo]=""
  for k in range(len(df_Ciudad['Fecha'])-1):
    df_Ciudad["Tasa_Muerte"+ Tipo][k+1]=(df_Ciudad['Casos_Muerte'+ Tipo][k+1]-df_Ciudad['Casos_Muerte'+ Tipo][k])/(df_Ciudad['Casos_Activos'+ Tipo][k])

  ## Aquí se establece la tasa para la predicción a partir de los últimos datos: promedio, promedio más 2 veces desviación estándar y promedio menos 2 veces desviación estándar

  if Tipo == '': 
    Tasa_Contagio=df_Ciudad["Tasa_Contagio"+Tipo][-25:].mean()
    Tasa_Recuperacion=df_Ciudad["Tasa_Recuperacion"+Tipo][-25:].mean()
    Tasa_Muerte=df_Ciudad["Tasa_Muerte"+Tipo][-25:].mean()
  elif Tipo == '_Max':
    Tasa_Contagio=np.std(df_Ciudad["Tasa_Contagio_Max"][-25:])*2+df_Ciudad["Tasa_Contagio_Max"][-25:].mean()
    Tasa_Recuperacion=np.std(df_Ciudad["Tasa_Recuperacion_Max"][-25:])*2+df_Ciudad["Tasa_Recuperacion_Max"][-25:].mean()
    Tasa_Muerte=np.std(df_Ciudad["Tasa_Muerte_Max"][-25:])*2+df_Ciudad["Tasa_Muerte_Max"][-25:].mean()            
  elif Tipo == '_Min':
    Tasa_Contagio=np.std(df_Ciudad["Tasa_Contagio_Min"][-25:])*(-2)+df_Ciudad["Tasa_Contagio_Min"][-25:].mean()
    Tasa_Recuperacion=np.std(df_Ciudad["Tasa_Recuperacion_Min"][-25:])*(-2)+df_Ciudad["Tasa_Recuperacion_Min"][-25:].mean()
    Tasa_Muerte=np.std(df_Ciudad["Tasa_Muerte_Min"][-25:])*(-2)+df_Ciudad["Tasa_Muerte_Min"][-25:].mean()
        
  ## Aquí se aplica la predicción y se va llenando el dataframe

  Lista=[]
  for k in range(30):
    
    Lista_fecha=df_Ciudad['Fecha'][len(df_Ciudad)-1] + datetime.timedelta(days=1)
    Lista_casos=(Tasa_Contagio*df_Ciudad["Casos_Activos"+ Tipo][len(df_Ciudad)-1]*(Pobla-df_Ciudad["Casos_Diagnostico"+ Tipo][len(df_Ciudad)-1])/Pobla)
    Lista_recuperados=Tasa_Recuperacion*df_Ciudad["Casos_Activos"+ Tipo][len(df_Ciudad)-1]
    Lista_muertes=Tasa_Muerte*df_Ciudad["Casos_Activos"+ Tipo][len(df_Ciudad)-1]

   ## Aquí se incluyen reglas de coherencia de datos

    if Lista_casos>Pobla:
      break
    elif Lista_casos<0:
      Lista_casos=df_Ciudad["Casos_Diagnostico"+ Tipo][len(df_Ciudad)-1]
    else:
      Lista_casos=Lista_casos+df_Ciudad["Casos_Diagnostico"+ Tipo][len(df_Ciudad)-1]
    
    if Lista_recuperados<0:
      Lista_recuperados=df_Ciudad["Casos_Recuperado"+ Tipo][len(df_Ciudad)-1]
    else:
      Lista_recuperados=Lista_recuperados+df_Ciudad["Casos_Recuperado"+ Tipo][len(df_Ciudad)-1]
    
    if Lista_muertes<0:
      Lista_muertes=df_Ciudad["Casos_Muerte"+ Tipo][len(df_Ciudad)-1]
    else:
      Lista_muertes=Lista_muertes+df_Ciudad["Casos_Muerte"+ Tipo][len(df_Ciudad)-1]
    
    Lista_activos=Lista_casos-Lista_recuperados-Lista_muertes
    Lista=[[Lista_fecha,round(Lista_casos),round(Lista_recuperados),round(Lista_muertes),round(Lista_activos),None,None,None]]
    

    dfnuevo = pd.DataFrame(Lista, columns = ["Fecha","Casos_Diagnostico"+ Tipo, "Casos_Recuperado"+ Tipo, "Casos_Muerte"+ Tipo,"Casos_Activos"+ Tipo,"Tasa_Contagio"+ Tipo,"Tasa_Recuperacion"+ Tipo,"Tasa_Muerte"+ Tipo])
    df_Ciudad=pd.concat([df_Ciudad,dfnuevo], ignore_index=True)

  ## Para mejor desempeño de Data Studio, se modifica el nombre "Cali" por "Santiago de Cali"

  df_Ciudad["Pais"]="Colombia"
  df_Ciudad["Ciudad"]=Ciudad
  
  return df_Ciudad

##Llamar la función y envio de total de población para cada ciudad (cifras DANE)
    ##Se calcula una predicción con un maximo y mímino de las tasas dependientes en base al promedio
Ciudades= [("Medellín",2372330),("Bogotá D.C.",7181469),("Santiago de Cali",1822869),("Barranquilla",1120103),("Pereira",409670)]
Tipo= ["","_Max","_Min"]
for ti in Tipo:
    for ci in Ciudades:
      if ci[0]=="Medellín":
        df_final=Agrupacion(df0,ci[0],ci[1],ti)
      else:
        df_concat=Agrupacion(df0,ci[0],ci[1],ti)
        df_final=pd.concat([df_final, df_concat])

    df_final["Fecha"]=df_final["Fecha"].dt.strftime("%Y/%m/%d")
    # df_final['Año']=df_final['Fecha'].dt.year
    # df_final['Mes']=df_final['Fecha'].dt.month
    # df_final['Día']=df_final['Fecha'].dt.day
    df_final.to_csv('COVID19_COLOMBIA'+ ti.upper() + '.csv',index=False)

import math
import matplotlib.pyplot as plt
import numpy as np

"""# ****Análisis con el modelo de regresión****

En un analisis del problema se identifico que las caracterisiticas para entender el mismo no sugerian una solución de tipo clasificación o agrupación sino mas bien de un entendimiento de los datos a traves del tiempo, por lo cual se consideraron modelos con series de tiempo, regresiones o SIR, que representan el comportamiento de los datos vs la temporalidad de los mismos, a continuación presentamos un intento por generar el comportamiento y la predicción a partir de polinomios, donde se probo la predicción a corto y mediano plazo sin obtener una representación esperada de las variables. Por esta razón finalmente se opto por hacer uso del SIR.
"""

Bog=Agrupacion(df0,"Bogotá D.C.",7181469,"")
print(Bog.head(5))
Bog=Bog[:-30]

def model(N):
    w = np.polyfit(Bog.index,Bog["Casos_Diagnostico"], N)
    return np.poly1d(w)

def modelo(N):
    w = np.polyfit(Bog.index,Bog["Casos_Activos"], N)
    return np.poly1d(w)

history = []
for n in range(1, 16):
    m = modelo(n)
    y_data = m(Bog.index)
    history.append(sum((Bog["Casos_Diagnostico"] - y_data) ** 2))
plt.plot(range(1, len(history) + 1), history, "o-", color="k")
plt.xlabel("Grado del polinomio")
plt.ylabel("SSE")
plt.grid()
plt.show()

plt.figure(figsize=(11, 10))

grados = list(range(1, 15))

lista=[k for k in range(0,190)]

for i, n in enumerate(grados):

    m = modelo(n)
    y_data = m(lista)

    plt.subplot(5, 3, i + 1)
    plt.plot(Bog.index, Bog["Casos_Activos"], ".", color="black")
    plt.plot(lista, y_data, color="red")
    plt.xlabel(n)
    plt.show()

"""Al no usar modelos de clasificación no es necesario presentar metricas de calibración o intervalos de confianza sin embargo se presentan varios esecenarios ( hoja 2 dashboard), en una especie de analisis de sensibilidad cambiando los valores de las variables dependientes (tasas) con el fin de presentar la coherencia del modelo para predecir el comportamiento.

## *Conclusiones*

 



*   En la implementación del modelo de regresión polinomial se concluyó que la extrapolación con diferentes grados del modelo, presenta un comportamiento incoherente con respecto al esperado a mediano y largo plazo de  la predicción sin importar el grado del polinomio los resultados no  son concluyentes.

*   Los modelos de clasificación no se tuvieron en cuenta ya que desde un análisis teórico del problema no consideramos la clasificación sino el análisis de  los modelos que relacionan el comportamiento de los datos con respecto a un periodo del tiempo, como las regresiones, series de tiempo y en su defecto el SIR. 


*  Despues del  proceso de limpieza y adecuación de la base de datos, se realizó el modelo de predicción del Covid-19 a través del método SIR, empleando tres escenarios o ambientes de simulación con los datos extrapolados a un mes para determinar el comportamiento de los casos activos, recuperados, diagnosticados y muertes; con los cuales logramos obtener que los comportamientos y resultados finales de la predicción del Covid-19 son coherentes con  la situación actual que se está viviendo en Colombia.

*   Para tener en cuenta escenarios que se pueden ir dando en relación con la pandemia, se  analizan cambios en las  tasas de contagio, de recuperacion y muerte con el promedio de los últimos 25 días más dos veces la desviación estandar teniendo en cuenta  la finalización de la cuarentena obligatoria y el posible comportamiento indiferente  de las personas con respecto al mismo, de igual manera, se calculó el promedio de las tasas menos dos veces la desviación estandar para presentar un panorama donde la población sigue responsable y precavida frente al virus, es decir, se asume que se sigue aplicando el autocuidado.


*   El modelo SIR se aplica en esta predicción dado que es uno de los modelos más adecuados para describir la dinámica de los contagios en una población con (N) individuos que inicialmente son susceptibles (S), luego  a partir del tiempo van pasando a ser infectados (I) y tras un periodo de enfermedad activa, los que no fallecen pasan a un estado de recuperados (R), por lo que la población susceptible va  reduciendo,todo esto en relación con un periodo de tiempo determinado.
"""